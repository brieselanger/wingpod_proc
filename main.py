#Main programme to run the pre- and postprocessing for 3D wind calulation
#2019/02/10
#Alexander Buetow
#Institute for Space Sciences
#Free University of Berlin

#+++MODULES+++
import numpy as np
import pandas as pd
import sys
import os
import importlib
#import matplotlib.pyplot as plt #plotting funcion to be implemented

#get and set working directory before importing costum wingpodproc libraries
mod_dir = os.getcwd() + '/'
in_dir = mod_dir + 'in/'
out_dir = mod_dir + 'out/'
sys.path.append(mod_dir) #append current directory to import costum libraries

#costum libraries
from conf import * #Configuration (file names, directories etc.)
from const import * #Calibration Constants
import lib.load_data as ld
import lib.preprocessing as pp
import lib.routine_wind as wc #3D-wind vector calculation routine
import lib.exporting as exp
import lib.meteo as mt


#reloading configuration and libraries (if changes were applied)
for module in ['conf','const']:
    mod = importlib.reload(sys.modules[module])
    vars().update(mod.__dict__)
importlib.reload(pp)

#+++CONFIGURATION+++
testing = False #enables/disables testsection

#+++FUNCTIONS+++

#+++PROGRAMME+++

print('Input directory: ' + in_dir)

#Loading data
cpt_spd = ld.load_cpt6100(in_dir + cpt_spd, 'p_spd')
cpt_alt = ld.load_cpt6100(in_dir + cpt_alt, 'p_alt')
cpt_bet = ld.load_cpt6100(in_dir + cpt_bet, 'p_bet')
cpt_alp = ld.load_cpt6100(in_dir + cpt_alp, 'p_alp')
hmt_data = ld.load_hmt310(in_dir + vais)
usb1608_data = ld.load_usb1608(in_dir + pt100)
nova0,nova1 = ld.load_novatel(in_dir + imu_data, leap=utc_leap)

#export kml file of flight track
if kml_export: #kml export of flight path
    print('Export raw INS track as kml file')
    exp.kml_imu_export(nova1,path=out_dir)
 
#Preprocessing
#
print('Preprocessing data...')
#filter out absolute outliers. Before passing the non-SI limit values, they
#   have to be converted into SI

cpt_spd = pp.hard_limit(cpt_spd, cols=['p_spd'],
                        lims=[[x * 100 for x in p_lim_spd]])
cpt_alt = pp.hard_limit(cpt_alt, cols=['p_alt'],
                        lims=[[x * 100 for x in p_lim_alt]])
cpt_alp = pp.hard_limit(cpt_alp, cols=['p_alp'],
                        lims=[[x * 100 for x in p_lim_diff]])
cpt_bet = pp.hard_limit(cpt_bet, cols=['p_bet'],
                        lims=[[x * 100 for x in p_lim_diff]])
hmt_data = pp.hard_limit(hmt_data, cols=['T','Td'],
                         lims=[[x +273.15 for x in T_lim_hmt],
                               [x + 273.15 for x in Td_lim_hmt]])
#usb1608_data, nova0, nova1: no hard limits set

#put all together in a dictionary
data = {'p_spd': cpt_spd, 'p_alt': cpt_alt, 'p_alp': cpt_alp,
        'p_bet': cpt_bet,'hmt311': hmt_data, 'usb1608': usb1608_data,
        'nova0': nova0, 'nova1': nova1}

#re-zero pressure measurements and remove response time lag
for var in ['p_alp', 'p_bet', 'p_spd', 'p_alt']:
    data[var][var] = pp.p_offset_corr(data[var][var], p_offset[var] * 100)
    data[var]['time'] = pp.time_offset_corr(data[var]['time'],
                                            p_time_offset[var])

#TO-DO:
#determine reference date and subtract it from timestamps. This is necessary 
#   because the very lenghtly UNIX-timestamp will suffer precision after
#   upsampling. Therefore, the timestamp will be splitted into two parts: UNIX
#   timestamp at 00:00 UTC and the seconds thereafter.
    
#apply timestamp-smoothing...required because timestamps generated by the RPi
#jitter due to high i/o load while logging. Time selection applied ist apllied
#here, too.
for key in data:
    data[key] = pp.jitter_corr(data[key], key, smooth)

#synchronizing
data = pp.sync(dfs=data, dfm='nova0', dfm_gnss_col='gnss_time_2',
               intp_wdth=upsmpl_rate, skip_cols=['gnss_time_1', 'gnss_time_2'],
               periodic=['psi'])

#apply time selection
data = pp.time_selection(data, time_sel)

#append indicated flow angles
data['alp_i'] = wc.ups_angl(data['p_spd'], data['p_alp'], C_k, 0)
data['bet_i'] = wc.ups_angl(data['p_spd'], data['p_bet'], C_k, 0)

#apply speed dependend static pressure error
data['ps_q_err'] = pp.dyn_press_ps_error(data['p_spd'], ps_q_corr)

#pressure correction for indicated static and dynamic pressure ports
for var in ['p_alt','p_spd']:
    if var == 'p_spd':
        corr = data['ps_q_err'] #yaw angle corr. disabled
    elif var == 'p_alt':
        corr = - data['ps_q_err']
    newvar = var + '_corr'
    data[newvar] = data[var] + corr
    
#apply speed dependend dynamic pressure error
data['q_q_err'] = pp.dyn_press_q_error(data['p_spd_corr'], q_q_corr)
data['p_spd_corr'] = data['p_spd_corr'] + data['q_q_err']

#append wind calculation data
data = pd.concat([data,
                 wc.wind_out(data['p_alt'], data['p_alt_corr'], data['p_spd'],
                          data['p_spd_corr'], data['p_alp'], data['p_bet'],
                          data['T'], data['theta'], data['theta_dot'],
                          data['psi'], data['psi_dot'], data['phi'],
                          data['u_p'], data['v_p'], data['w_p'],
                          alp0, bet0, C_alp, C_bet, L, r, simple=False)],
                axis=1)
                 
#append meteorological calculation
data = mt.add_meteo(data)
                 
#export kml-file with wind and debug information
if kml_export:
    print('Export preprocessed wind data as kmz file')
    exp.kml_wind_export(df=data, barb_path=mod_dir + 'data/barbs/',
                        out_path=out_dir, spd_scale=5, scale=2)

if csv_export:
    #TO DO: define float format for each column
    print('Export preprocessed wind data as compressed ASCII file')
    data.to_csv(out_dir + 'wind_export.csv.gz', float_format='%.4f', 
                index=False, compression='gzip')

print('Done.')

